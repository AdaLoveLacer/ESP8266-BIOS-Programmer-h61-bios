<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ESP8266 W25Q32BV Programmer - Optimized</title>
    <style>
        body { font-family: Arial; margin: 20px; background: #f0f0f0; }
        .container { max-width: 800px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; }
        .section { margin: 20px 0; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
        button { padding: 10px 15px; margin: 5px; background: #007cba; color: white; border: none; border-radius: 3px; cursor: pointer; }
        button:hover { background: #005a87; }
        input[type="file"] { margin: 10px 0; }
        .result { background: #f9f9f9; padding: 10px; margin: 10px 0; border-left: 4px solid #007cba; font-family: monospace; }
        .warning { background: #fff3cd; border-left: 4px solid #ffc107; }
        .error { background: #f8d7da; border-left: 4px solid #dc3545; }
        .success { background: #d4edda; border-left: 4px solid #28a745; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîß ESP8266 W25Q32BV BIOS Programmer - OPTIMIZADO</h1>
        <p>Gravador/Depurador para chip BIOS W25Q32BV (H61 Motherboard)</p>
        <div class="warning result">‚ö° VERS√ÉO OTIMIZADA: SPI 500kHz, Chunks 512B, Verifica√ß√£o por chunk</div>
        
        <div class="section">
            <h3>üåê Status de Conex√£o</h3>
            <button onclick="checkConnection()">Verificar Conex√£o</button>
            <div id="connectionInfo" class="result"></div>
        </div>
        
        <div class="section">
            <h3>üìã Informa√ß√µes do Chip</h3>
            <button onclick="readChipId()">Ler JEDEC ID</button>
            <button onclick="readStatus()">Status</button>
            <div id="chipInfo" class="result"></div>
        </div>
        
        <div class="section">
            <h3>üìñ Leitura</h3>
            <label>Endere√ßo (hex): <input type="text" id="readAddr" value="0x000000" style="width: 100px;"></label>
            <label>Tamanho (bytes): <input type="text" id="readSize" value="256" style="width: 80px;"></label>
            <br>
            <button onclick="readFlash()">Ler Dados</button>
            <button onclick="dumpFullBios()">Dump Completo (4MB)</button>
            <div id="readResult" class="result"></div>
        </div>
        
        <div class="section">
            <h3>‚úèÔ∏è Grava√ß√£o</h3>
            <input type="file" id="biosFile" accept=".bin,.rom,.bios">
            <br>
            <label><input type="checkbox" id="useStreaming" checked> Usar Streaming (recomendado)</label>
            <br>
            <label><input type="checkbox" id="autoVerify" checked> Verifica√ß√£o Autom√°tica</label>
            <br>
            <button onclick="writeBiosStream()">Gravar BIOS (Streaming Otimizado)</button>
            <button onclick="verifyBios()">Verificar BIOS Gravado</button>
            <div id="writeResult" class="result"></div>
            <div id="uploadProgress" style="display: none;">
                <div style="background: #ddd; border-radius: 3px; overflow: hidden;">
                    <div id="progressBar" style="background: #007cba; height: 20px; width: 0%; transition: width 0.3s;"></div>
                </div>
                <span id="progressText">0%</span>
            </div>
            <div id="verifyResult" class="result" style="display: none;"></div>
        </div>
        
        <div class="section">
            <h3>üóëÔ∏è Apagamento</h3>
            <div class="warning result">‚ö†Ô∏è CUIDADO: Apagar o chip tornar√° a placa m√£e inutiliz√°vel!</div>
            <label>Endere√ßo do Setor: <input type="text" id="eraseAddr" value="0x000000" style="width: 100px;"></label>
            <br>
            <button onclick="eraseSector()" style="background: #dc3545;">Apagar Setor (64KB)</button>
            <button onclick="eraseChip()" style="background: #dc3545;">Apagar Chip Completo</button>
            <div id="eraseResult" class="result"></div>
        </div>
        
        <div class="section">
            <h3>üîß Sistema & Debug</h3>
            <button onclick="checkSystem()">Verificar Sistema</button>
            <button onclick="testConnections()">Testar Conex√µes SPI</button>
            <button onclick="diagnosticTest()">Diagn√≥stico Avan√ßado</button>
            <button onclick="sectorTest()">Teste Setor por Setor</button>
            <div id="systemInfo" class="result"></div>
        </div>
    </div>

    <script>
        // Vari√°veis globais para verifica√ß√£o
        let originalFileData = null;
        let originalFileName = '';
        let originalFileSize = 0;
        let originalChecksum = '';

        // Fun√ß√£o para calcular CRC32
        function crc32(data) {
            const table = [];
            for (let i = 0; i < 256; i++) {
                let c = i;
                for (let j = 0; j < 8; j++) {
                    c = (c & 1) ? 0xEDB88320 ^ (c >>> 1) : c >>> 1;
                }
                table[i] = c;
            }
            let crc = 0 ^ (-1);
            for (let i = 0; i < data.length; i++) {
                crc = (crc >>> 8) ^ table[(crc ^ data[i]) & 0xFF];
            }
            return (crc ^ (-1)) >>> 0;
        }

        // Monitor de arquivo carregado
        document.addEventListener('DOMContentLoaded', function() {
            const fileInput = document.getElementById('biosFile');
            fileInput.addEventListener('change', async function(e) {
                if (e.target.files.length > 0) {
                    const file = e.target.files[0];
                    originalFileName = file.name;
                    originalFileSize = file.size;
                    
                    const arrayBuffer = await file.arrayBuffer();
                    originalFileData = new Uint8Array(arrayBuffer);
                    originalChecksum = crc32(originalFileData).toString(16).toUpperCase();
                    
                    console.log('Arquivo carregado:', originalFileName, '(', originalFileSize, 'bytes)');
                    console.log('CRC32:', originalChecksum);
                    
                    document.getElementById('writeResult').innerHTML = 
                        '<div class="success">üìÅ Arquivo: ' + originalFileName + 
                        '<br>üìè Tamanho: ' + originalFileSize + ' bytes' +
                        '<br>üîê CRC32: ' + originalChecksum + '</div>';
                }
            });
        });

        // Fun√ß√£o de conex√£o
        function checkConnection() {
            document.getElementById('connectionInfo').innerHTML = 'üîÑ Verificando...';
            fetch('/system')
                .then(r => r.json())
                .then(d => {
                    const ip = window.location.hostname;
                    const isAP = ip.startsWith('192.168.4.');
                    const type = isAP ? 'üì° Access Point' : 'üåê WiFi Router';
                    document.getElementById('connectionInfo').innerHTML = 
                        '<div class="success"><b>' + type + '</b><br>IP: ' + ip + '<br>RAM: ' + d.freeHeap + ' bytes<br>‚ö° SPI: 500kHz (Otimizado)</div>';
                })
                .catch(e => document.getElementById('connectionInfo').innerHTML = '<div class="error">Erro: ' + e + '</div>');
        }

        // Fun√ß√µes b√°sicas
        function readChipId() {
            fetch('/id')
                .then(r => r.json())
                .then(d => {
                    const info = d.id === 'EF4016' ? 
                        '<div class="success">‚úÖ W25Q32BV (' + d.id + ')</div>' : 
                        '<div class="error">‚ùå ID: ' + d.id + '</div>';
                    document.getElementById('chipInfo').innerHTML = info;
                })
                .catch(e => document.getElementById('chipInfo').innerHTML = '<div class="error">' + e + '</div>');
        }

        function readStatus() {
            fetch('/status')
                .then(r => r.json())
                .then(d => {
                    const status = d.busy ? 'üîÑ Ocupado' : '‚úÖ Pronto';
                    const wp = d.writeProtected ? 'üîí Protegido' : 'üîì Grav√°vel';
                    document.getElementById('chipInfo').innerHTML = '<div>Status: ' + status + '<br>Write Protection: ' + wp + '</div>';
                })
                .catch(e => document.getElementById('chipInfo').innerHTML = '<div class="error">' + e + '</div>');
        }

        // Dump com chunks menores para maior confiabilidade
        async function dumpFullBios() {
            document.getElementById('readResult').innerHTML = 'üîÑ Iniciando dump streaming (4MB)...';
            document.getElementById('uploadProgress').style.display = 'block';
            
            try {
                const totalSize = 4194304; // 4MB
                const chunkSize = 2048;    // 2KB chunks para maior confiabilidade
                const totalChunks = Math.ceil(totalSize / chunkSize);
                
                const biosData = new Uint8Array(totalSize);
                let offset = 0;
                
                for (let i = 0; i < totalChunks; i++) {
                    const currentChunkSize = Math.min(chunkSize, totalSize - offset);
                    const hexAddr = '0x' + offset.toString(16).padStart(6, '0').toUpperCase();
                    
                    const response = await fetch('/read?addr=' + hexAddr + '&size=' + currentChunkSize);
                    if (!response.ok) throw new Error('Falha no chunk ' + (i + 1));
                    
                    const chunkBuffer = await response.arrayBuffer();
                    biosData.set(new Uint8Array(chunkBuffer), offset);
                    offset += currentChunkSize;
                    
                    const progress = ((i + 1) / totalChunks) * 100;
                    document.getElementById('progressBar').style.width = progress + '%';
                    document.getElementById('progressText').textContent = Math.round(progress) + '%';
                    
                    // Delay menor para chunks menores
                    await new Promise(resolve => setTimeout(resolve, 5));
                }
                
                const blob = new Blob([biosData], { type: 'application/octet-stream' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'bios_backup_' + new Date().toISOString().slice(0, 19).replace(/:/g, '-') + '.bin';
                a.click();
                window.URL.revokeObjectURL(url);
                
                document.getElementById('readResult').innerHTML = '<div class="success">‚úÖ Backup completo!</div>';
            } catch (err) {
                document.getElementById('readResult').innerHTML = '<div class="error">‚ùå ' + err.message + '</div>';
            } finally {
                document.getElementById('uploadProgress').style.display = 'none';
            }
        }

        // Grava√ß√£o otimizada com chunks menores
        async function writeBiosStream() {
            if (!originalFileData) {
                alert('Selecione um arquivo BIOS primeiro!');
                return;
            }

            document.getElementById('writeResult').innerHTML = 'üîÑ Iniciando grava√ß√£o streaming otimizada...';
            document.getElementById('uploadProgress').style.display = 'block';
            document.getElementById('verifyResult').style.display = 'none';

            try {
                // 1. Inicializar upload
                const response = await fetch('/writeStream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'init', size: originalFileSize })
                });
                if (!response.ok) throw new Error('Falha ao inicializar streaming');

                // 2. Enviar arquivo em chunks menores para maior confiabilidade
                const chunkSize = 512; // 512 bytes para m√°xima confiabilidade
                const totalChunks = Math.ceil(originalFileSize / chunkSize);
                
                for (let i = 0; i < totalChunks; i++) {
                    const start = i * chunkSize;
                    const end = Math.min(start + chunkSize, originalFileSize);
                    const chunk = originalFileData.slice(start, end);
                    const base64 = btoa(String.fromCharCode(...chunk));
                    
                    const chunkResponse = await fetch('/writeChunk', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ data: base64 })
                    });
                    
                    if (!chunkResponse.ok) throw new Error('Falha chunk ' + (i + 1));
                    
                    const progress = ((i + 1) / totalChunks) * 100;
                    document.getElementById('progressBar').style.width = progress + '%';
                    document.getElementById('progressText').textContent = 'Gravando ' + Math.round(progress) + '%';
                    
                    // Delay menor para chunks menores
                    await new Promise(resolve => setTimeout(resolve, 5));
                }

                // 3. Finalizar
                const finishResponse = await fetch('/writeStream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'finish' })
                });

                if (finishResponse.ok) {
                    document.getElementById('writeResult').innerHTML = '<div class="success">‚úÖ Grava√ß√£o conclu√≠da com verifica√ß√£o por chunk!</div>';
                    if (document.getElementById('autoVerify').checked) {
                        setTimeout(() => { verifyBios(); }, 1500);
                    }
                } else {
                    throw new Error('Falha ao finalizar grava√ß√£o');
                }

            } catch (err) {
                document.getElementById('writeResult').innerHTML = '<div class="error">‚ùå ' + err.message + '</div>';
            } finally {
                document.getElementById('uploadProgress').style.display = 'none';
            }
        }

        // Verifica√ß√£o otimizada
        async function verifyBios() {
            if (!originalFileData) {
                document.getElementById('verifyResult').innerHTML = '<div class="error">‚ùå Nenhum arquivo original para comparar</div>';
                document.getElementById('verifyResult').style.display = 'block';
                return;
            }

            document.getElementById('verifyResult').innerHTML = 'üîÑ Iniciando verifica√ß√£o...';
            document.getElementById('verifyResult').style.display = 'block';
            document.getElementById('uploadProgress').style.display = 'block';

            try {
                const totalSize = originalFileSize;
                const chunkSize = 2048; // 2KB para verifica√ß√£o
                const totalChunks = Math.ceil(totalSize / chunkSize);
                const readData = new Uint8Array(totalSize);
                let offset = 0;

                for (let i = 0; i < totalChunks; i++) {
                    const currentChunkSize = Math.min(chunkSize, totalSize - offset);
                    const hexAddr = '0x' + offset.toString(16).padStart(6, '0').toUpperCase();
                    
                    const response = await fetch('/read?addr=' + hexAddr + '&size=' + currentChunkSize);
                    if (!response.ok) throw new Error('Falha na leitura chunk ' + (i + 1));
                    
                    const chunkBuffer = await response.arrayBuffer();
                    readData.set(new Uint8Array(chunkBuffer), offset);
                    offset += currentChunkSize;
                    
                    const progress = ((i + 1) / totalChunks) * 100;
                    document.getElementById('progressBar').style.width = progress + '%';
                    document.getElementById('progressText').textContent = 'Verificando ' + Math.round(progress) + '%';
                    
                    await new Promise(resolve => setTimeout(resolve, 3));
                }

                const readChecksum = crc32(readData).toString(16).toUpperCase();
                const isMatch = readChecksum === originalChecksum;

                let result = '<div class="' + (isMatch ? 'success' : 'error') + '"><h4>' + 
                            (isMatch ? '‚úÖ VERIFICA√á√ÉO PASSOU' : '‚ùå VERIFICA√á√ÉO FALHOU') + '</h4>';
                result += '<b>Arquivo Original:</b><br>‚Ä¢ Nome: ' + originalFileName + 
                         '<br>‚Ä¢ Tamanho: ' + originalFileSize + ' bytes<br>‚Ä¢ CRC32: ' + originalChecksum + '<br><br>';
                result += '<b>Dados Lidos do Chip:</b><br>‚Ä¢ Tamanho: ' + readData.length + 
                         ' bytes<br>‚Ä¢ CRC32: ' + readChecksum + '<br><br>';

                if (isMatch) {
                    result += 'üéâ <b>Os dados s√£o id√™nticos!</b><br>‚úÖ BIOS gravado com sucesso (SPI otimizado funcionou!)';
                } else {
                    result += '‚ö†Ô∏è <b>Os dados s√£o diferentes!</b><br>‚ùå Erro na grava√ß√£o ou corrup√ß√£o<br>';
                    result += 'üí° <b>Sugest√µes:</b><br>‚Ä¢ Tentar novamente com SPI ainda mais lento<br>‚Ä¢ Verificar conex√µes f√≠sicas<br>‚Ä¢ Executar diagn√≥stico avan√ßado';
                }
                result += '</div>';

                document.getElementById('verifyResult').innerHTML = result;

            } catch (err) {
                document.getElementById('verifyResult').innerHTML = '<div class="error">‚ùå ' + err.message + '</div>';
            } finally {
                document.getElementById('uploadProgress').style.display = 'none';
            }
        }

        // Outras fun√ß√µes b√°sicas
        function readFlash() {
            const addr = document.getElementById('readAddr').value;
            const size = document.getElementById('readSize').value;
            
            fetch('/read?addr=' + addr + '&size=' + size)
                .then(r => r.text())
                .then(d => {
                    document.getElementById('readResult').innerHTML = '<strong>Dados:</strong><br>' + d.substring(0, 1000);
                })
                .catch(e => document.getElementById('readResult').innerHTML = '<div class="error">' + e + '</div>');
        }

        function checkSystem() {
            fetch('/system')
                .then(r => r.json())
                .then(d => {
                    const info = '<div class="success"><b>Sistema ESP8266:</b><br>‚Ä¢ RAM: ' + d.freeHeap + 
                                ' bytes<br>‚Ä¢ Uptime: ' + Math.floor(d.uptime / 1000) + 
                                ' s<br>‚ö° SPI: 500kHz (Otimizado)<br><b>W25Q32BV:</b><br>‚Ä¢ JEDEC ID: ' + d.jedecId + '</div>';
                    document.getElementById('systemInfo').innerHTML = info;
                })
                .catch(e => document.getElementById('systemInfo').innerHTML = '<div class="error">' + e + '</div>');
        }

        // Inicializar interface
        window.onload = function() {
            readChipId();
            checkConnection();
        };
    </script>
</body>
</html>